#!/usr/bin/env python3
# File: tools/secret-hound/bin/secret-hound
# Description: Final, robust version of the user-facing entry point.
# This version includes fixes for git-scan, confidence filtering, and result deduplication.

import sys
import argparse
import subprocess
import json
import os
import threading
from pathlib import Path
from collections import defaultdict

# --- START: Core SNIPER Environment Integration ---
try:
    _PROJECT_ROOT = Path(__file__).resolve().parents[3]
    sys.path.insert(0, str(_PROJECT_ROOT))
    
    from lib.sniper_env import env
    from lib.help_renderer import render_help
    from lib.sniper_env import Colors

    env.log.name = "secret-hound"
except (ImportError, IndexError):
    class Colors:
        RED = '\033[91m'; GREEN = '\033[92m'; YELLOW = '\033[93m'; BLUE = '\033[94m'
        MAGENTA = '\033[95m'; CYAN = '\033[96m'; BOLD = '\033[1m'; RESET = '\033[0m'; GREY = '\033[90m'
    class DummyLog:
        def error(self, msg, **kwargs): print(f"{Colors.RED}[ERROR] {msg}{Colors.RESET}", file=sys.stderr)
        def warning(self, msg, **kwargs): print(f"{Colors.YELLOW}[WARN] {msg}{Colors.RESET}", file=sys.stderr)
        def success(self, msg, **kwargs): print(f"{Colors.GREEN}[SUCCESS] {msg}{Colors.RESET}")
    class DummyEnv:
        log = DummyLog(); ROOT_DIR = Path('.')
    env = DummyEnv()
    def render_help(data): print("Help screen unavailable.")
    print(f"{Colors.RED}[CRITICAL ERROR] Could not initialize SNIPER environment.\033[0m", file=sys.stderr)
# --- END: Core SNIPER Environment Integration ---

backend_process = None

def get_tool_path(tool_name: str) -> str:
    """Finds the absolute path to a binary in the main sniper bin directory."""
    path = env.ROOT_DIR / "bin" / tool_name
    if not (path.is_file() and os.access(path, os.X_OK)):
        path = env.ROOT_DIR / "tools" / "secret-hound" / "bin" / tool_name
        if not (path.is_file() and os.access(path, os.X_OK)):
             raise FileNotFoundError(f"Required binary '{tool_name}' not found or is not executable.")
    return str(path)

def stream_reader(pipe, is_stderr):
    """Reads from a pipe (stdout/stderr) and prints stderr, for use in a thread."""
    try:
        for line in iter(pipe.readline, ''):
            if is_stderr:
                sys.stderr.write(f"{Colors.GREY}BE-LOG: {line.strip()}{Colors.RESET}\n")
    finally:
        pipe.close()

def run_backend_and_get_findings(command: list) -> list:
    """Runs a backend process and returns a list of all findings."""
    global backend_process
    findings = []
    
    try:
        backend_process = subprocess.Popen(
            command, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            text=True, encoding='utf-8', bufsize=1
        )
        stderr_thread = threading.Thread(target=stream_reader, args=(backend_process.stderr, True), daemon=True)
        stderr_thread.start()

        for line in backend_process.stdout:
            try:
                findings.append(json.loads(line))
            except json.JSONDecodeError:
                continue

        backend_process.wait()
        stderr_thread.join()

        if backend_process.returncode != 0:
            env.log.warning(f"Backend scanner exited with a non-zero status code ({backend_process.returncode}).")

    finally:
        if backend_process and backend_process.poll() is None:
            backend_process.terminate()
        backend_process = None
    
    return findings

def filter_and_deduplicate_findings(findings: list, confidence_level: str) -> list:
    """
    Filters findings by confidence level and removes duplicates/subsets.
    Prioritizes High > Medium > Low confidence findings for the same match.
    """
    confidence_map = {"low": 0, "medium": 1, "high": 2}
    min_confidence = confidence_map.get(confidence_level.lower(), 0)

    # Filter by confidence level first
    filtered = [f for f in findings if confidence_map.get(f.get("confidence", "low").lower(), 0) >= min_confidence]
    
    # Key: (file, line, matched_string), Value: highest confidence finding
    best_findings = {}

    for f in sorted(filtered, key=lambda x: confidence_map.get(x.get("confidence", "low").lower(), 0), reverse=True):
        key = (f.get('file'), f.get('line'), f.get('match'))
        
        is_subset = False
        for existing_key, _ in best_findings.items():
            # If the current match is a substring of an already found, higher-priority match in the same line, skip it.
            if existing_key[0] == key[0] and existing_key[1] == key[1] and key[2] in existing_key[2]:
                is_subset = True
                break
        
        if not is_subset:
            best_findings.setdefault(key, f)

    return list(best_findings.values())


def print_report(findings: list):
    """Renders the final, lightweight report to the console."""
    if not findings:
        print(f"\n{Colors.GREEN}✔ No secrets were found based on the current rules and filters.{Colors.RESET}", flush=True)
        return

    grouped_findings = defaultdict(list)
    for f in findings:
        key = f.get('original_path') or f.get('file')
        grouped_findings[key].append(f)

    header_text = f"Found {len(findings)} potential secret(s) in {len(grouped_findings)} file(s)"
    print(f"\n{Colors.YELLOW}{Colors.BOLD}--- {header_text} ---{Colors.RESET}", flush=True)

    for file_path, file_findings in sorted(grouped_findings.items()):
        git_info = ""
        if 'commit' in file_findings[0]:
            commit_hash = file_findings[0]['commit'][:8]
            git_info = f" {Colors.GREY}(Commit: {commit_hash}){Colors.RESET}"
        
        print(f"\n📁 {Colors.CYAN}{Colors.BOLD}{file_path}{Colors.RESET}{git_info}", flush=True)
        file_findings.sort(key=lambda x: x.get('line', 0))

        for finding in file_findings:
            line_num = finding.get('line', '?')
            rule_id = finding.get('rule_id', 'UnknownRule')
            match_str = finding.get('match', '')
            
            entropy = finding.get('entropy', 0.0)
            entropy_color = Colors.RED if entropy > 4.5 else Colors.YELLOW if entropy > 3.5 else Colors.GREY
            entropy_text = f" {Colors.GREY}(Entropy: {entropy_color}{entropy:.2f}{Colors.GREY}){Colors.RESET}" if entropy > 0 else ""
            
            max_len = 80
            if len(match_str) > max_len:
                match_str = match_str[:max_len-3] + "..."

            print(
                f"  {Colors.CYAN}L{line_num:<4}{Colors.RESET} "
                f"{Colors.MAGENTA}[{rule_id}]{Colors.RESET} "
                f"{Colors.RED}\"{match_str}\"{Colors.RESET}"
                f"{entropy_text}",
                flush=True
            )

def main():
    parser = argparse.ArgumentParser(prog="secret-hound", add_help=False)
    parser.add_argument("path", nargs='?', default=".", help="File or directory to scan.")
    parser.add_argument("-r", "--rules", help="Path to a custom JSON rules file.")
    parser.add_argument("-o", "--output", help="File to save the report (JSON format).")
    parser.add_argument("--scan-git", action="store_true", help="Scan the Git history.")
    parser.add_argument("--depth", type=int, default=100, help="Depth of Git history to scan.")
    parser.add_argument("--confidence", choices=['low', 'medium', 'high'], default='low', help="Minimum confidence level to report.")
    parser.add_argument("-h", "--help", action="store_true", help="Show help message.")
    
    args = parser.parse_args()

    if args.help:
        # Code to render help screen
        # ... (omitted for brevity, remains the same)
        return 0
        
    try:
        backend_cmd = []
        # --- FIX for --scan-git ---
        if args.scan_git:
            print("⟳ Scanning Git history...", end="\r", flush=True)
            go_analyzer_path = get_tool_path("git_analyzer")
            core_scanner_path = get_tool_path("hound-core")
            backend_cmd = [go_analyzer_path, core_scanner_path, str(args.depth)]
        else:
            print("⟳ Scanning filesystem...", end="\r", flush=True)
            core_scanner_path = get_tool_path("hound-core")
            backend_cmd = [core_scanner_path, args.path]
            if args.rules:
                backend_cmd.extend(["--rules", args.rules])
        
        # 1. Get all raw findings from the backend
        raw_findings = run_backend_and_get_findings(backend_cmd)
        
        # 2. Filter and process the findings
        final_findings = filter_and_deduplicate_findings(raw_findings, args.confidence)
        
        # 3. Print the clean report
        print_report(final_findings)

        if args.output:
            try:
                with open(args.output, 'w', encoding='utf-8') as f:
                    json.dump(final_findings, f, indent=2)
                env.log.success(f"Report successfully saved to {args.output}")
            except Exception as e:
                env.log.error(f"Failed to save report to {args.output}: {e}")
                return 1

    except FileNotFoundError as e:
        env.log.error(str(e))
        return 1
    except KeyboardInterrupt:
        if backend_process and backend_process.poll() is None:
            backend_process.terminate()
            backend_process.wait()
        print("\n")
        env.log.warning("Scan cancelled by user.")
        return 1
    except Exception as e:
        env.log.error(f"An unexpected error occurred: {e}", exc_info=True)
        return 1
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
